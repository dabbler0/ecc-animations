// Generated by CoffeeScript 1.8.0

/*
 * drawtree.coffee
 * Quick-and-dirty tree visualization
 *
 * Copyright (c) 2013 Anthony Bau
 * MIT License.
 */

(function() {
  var PADDING, Tree, available, binaryanim, dfsanim, exports, firstNotIn, next, nextAvailable, parseCoffee, _last,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  PADDING = 10;

  exports = {};

  exports.Tree = Tree = (function() {
    function Tree(parent, value, depth, color, data) {
      this.parent = parent;
      this.value = value;
      this.depth = depth;
      this.color = color != null ? color : '#FFF';
      this.data = data != null ? data : null;
      if (this.parent != null) {
        this.parent.children.push(this);
      }
      this.children = [];
      this.dimensions = null;
    }

    Tree.prototype.computeDimensions = function(ctx, fontSize, lineHeight) {
      var bottomHeight, child, ref, topHeight, width, _i, _len, _ref;
      if (fontSize == null) {
        fontSize = 20;
      }
      if (lineHeight == null) {
        lineHeight = 20;
      }
      ctx.font = "" + fontSize + "px Arial";
      width = 0;
      topHeight = fontSize + lineHeight;
      bottomHeight = 0;
      _ref = this.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        child.computeDimensions(ctx, fontSize, lineHeight);
        bottomHeight = Math.max(child.dimensions.height, bottomHeight);
        width += child.dimensions.width;
      }
      if (width > (ref = ctx.measureText(this.value).width + PADDING)) {
        this.centerChildren = false;
      } else {
        this.centerChildren = true;
        this.childrenWidth = width;
        width = ref;
      }
      return this.dimensions = {
        width: width,
        height: topHeight + bottomHeight
      };
    };

    Tree.prototype.drawTreePath = function(ctx, fontSize, lineHeight, coords) {
      var child, runningLeft, top, _i, _len, _ref, _results;
      if (fontSize == null) {
        fontSize = 20;
      }
      if (lineHeight == null) {
        lineHeight = 20;
      }
      if (coords == null) {
        coords = {
          x: 20,
          y: 20
        };
      }
      ctx.strokeStyle = '#000';
      this.rectX = coords.x + (this.dimensions.width - ctx.measureText(this.value).width) / 2;
      this.rectY = coords.y - fontSize / 2;
      top = coords.y + fontSize + lineHeight;
      runningLeft = coords.x;
      if (this.centerChildren) {
        runningLeft += (this.dimensions.width - this.childrenWidth) / 2;
      }
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        child.drawTreePath(ctx, fontSize, lineHeight, {
          x: runningLeft,
          y: top
        });
        ctx.strokeStyle = '#000';
        ctx.beginPath();
        ctx.moveTo(coords.x + this.dimensions.width / 2, coords.y);
        ctx.lineTo(runningLeft + child.dimensions.width / 2, top);
        ctx.stroke();
        _results.push(runningLeft += child.dimensions.width);
      }
      return _results;
    };

    Tree.prototype.drawBoxPath = function(ctx, fontSize, lineHeight, coords) {
      var child, runningLeft, top, _i, _len, _ref;
      if (fontSize == null) {
        fontSize = 20;
      }
      if (lineHeight == null) {
        lineHeight = 20;
      }
      if (coords == null) {
        coords = {
          x: 20,
          y: 20
        };
      }
      ctx.strokeStyle = '#000';
      this.rectX = coords.x + (this.dimensions.width - ctx.measureText(this.value).width) / 2;
      this.rectY = coords.y;
      top = coords.y + fontSize + lineHeight;
      runningLeft = coords.x;
      if (this.centerChildren) {
        runningLeft += (this.dimensions.width - this.childrenWidth) / 2;
      }
      _ref = this.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        child.drawBoxPath(ctx, fontSize, lineHeight, {
          x: runningLeft,
          y: top
        });
        runningLeft += child.dimensions.width;
      }
      if (this.parent !== null) {
        ctx.strokeStyle = '#000';
        console.log('stroking rect', this.value);
        ctx.strokeRect(coords.x, coords.y, this.dimensions.width, this.dimensions.height);
        ctx.fillStyle = this.color;
        return ctx.fillRect(coords.x, coords.y, this.dimensions.width, this.dimensions.height);
      }
    };

    Tree.prototype.drawText = function(ctx, fontSize, lineHeight) {
      var child, _i, _len, _ref, _results;
      if (fontSize == null) {
        fontSize = 20;
      }
      if (lineHeight == null) {
        lineHeight = 20;
      }
      if (this.parent !== null) {
        ctx.strokeStyle = '#000';
        ctx.fillStyle = this.color;
        ctx.strokeRect(this.rectX, this.rectY, ctx.measureText(this.value).width, fontSize);
        ctx.fillRect(this.rectX, this.rectY, ctx.measureText(this.value).width, fontSize);
        ctx.fillStyle = '#000';
        ctx.font = "" + fontSize + "px 'Arial'";
        ctx.fillText(this.value, this.rectX, this.rectY + fontSize);
      }
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        _results.push(child.drawText(ctx, fontSize, lineHeight));
      }
      return _results;
    };

    Tree.prototype.drawTree = function(ctx, fontSize, lineHeight, coords) {
      if (fontSize == null) {
        fontSize = 20;
      }
      if (lineHeight == null) {
        lineHeight = 20;
      }
      if (coords == null) {
        coords = {
          x: 20,
          y: 20
        };
      }
      this.computeDimensions(ctx, fontSize, lineHeight);
      this.drawTreePath(ctx, fontSize, lineHeight, coords);
      return this.drawText(ctx, fontSize, lineHeight, {
        border: '#000',
        background: this.color
      });
    };

    Tree.prototype.drawBox = function(ctx, fontSize, lineHeight, coords) {
      if (fontSize == null) {
        fontSize = 20;
      }
      if (lineHeight == null) {
        lineHeight = 20;
      }
      if (coords == null) {
        coords = {
          x: 20,
          y: 20
        };
      }
      this.computeDimensions(ctx, fontSize, lineHeight);
      this.drawBoxPath(ctx, fontSize, lineHeight, coords);
      return this.drawText(ctx, fontSize, lineHeight, {
        border: 'transparent',
        background: 'transparent'
      });
    };

    Tree.prototype.draw = function() {
      return this.drawTree.apply(this, arguments);
    };

    Tree.prototype.getRoot = function() {
      var head;
      head = this;
      while (head.parent !== null) {
        head = head.parent;
      }
      return head;
    };

    return Tree;

  })();

  exports.parseTabdown = function(string) {
    var indent, line, lines, tree, _i, _len;
    lines = string.split('\n');
    tree = new Tree(null, 'root', -1);
    for (_i = 0, _len = lines.length; _i < _len; _i++) {
      line = lines[_i];
      indent = line.length - line.trimLeft().length;
      if (indent === line.length) {
        continue;
      } else if (indent > tree.depth) {
        tree = new Tree(tree, line.trimLeft(), indent);
      } else if (indent <= tree.depth) {
        while (!(tree.depth < indent)) {
          tree = tree.parent;
        }
        tree = new Tree(tree, line.trimLeft(), indent);
      }
    }
    while (tree.parent !== null) {
      tree = tree.parent;
    }
    return tree;
  };

  exports.parseLisp = function(string) {
    var char, editingHead, tree, _i, _len, _ref, _ref1, _ref2;
    tree = new Tree(null, 'root', 0);
    editingHead = false;
    for (_i = 0, _len = string.length; _i < _len; _i++) {
      char = string[_i];
      switch (char) {
        case '(':
          editingHead = true;
          tree = new Tree(tree, '', tree.depth + 1);
          break;
        case ')':
          while (tree.value.length === 0) {
            (_ref = tree.parent.children).splice.apply(_ref, [tree.parent.children.indexOf(tree), 1].concat(__slice.call(tree.children)));
            tree = tree.parent;
          }
          tree = tree.parent;
          break;
        case ' ':
        case '\n':
          if (!editingHead) {
            if (tree.value.length === 0) {
              (_ref1 = tree.parent.children).splice.apply(_ref1, [tree.parent.children.indexOf(tree), 1].concat(__slice.call(tree.children)));
            }
            tree = tree.parent;
          }
          editingHead = false;
          tree = new Tree(tree, '', tree.depth + 1);
          break;
        default:
          tree.value += char;
      }
    }
    while (tree.parent !== null) {
      if (tree.value.length === 0) {
        (_ref2 = tree.parent.children).splice.apply(_ref2, [tree.parent.children.indexOf(tree), 1].concat(__slice.call(tree.children)));
      }
      tree = tree.parent;
    }
    return tree;
  };

  parseCoffee = function(node) {
    var root;
    root = new Tree(null, node.constructor.name);
    node.eachChild(function(child) {
      var newNode;
      newNode = parseCoffee(child);
      newNode.parent = root;
      return root.children.push(newNode);
    });
    return root;
  };

  exports.parseCoffee = function(text) {
    return parseCoffee(CoffeeScript.nodes(text));
  };

  window.tabdown = exports;

  _last = function(a) {
    return a[a.length - 1];
  };

  firstNotIn = function(prefix, n) {
    var i, _i;
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      if (__indexOf.call(prefix, i) < 0) {
        return i;
      }
    }
    return null;
  };

  available = function(prefix, n) {
    var i, last, _i;
    last = _last(prefix);
    for (i = _i = last; last <= n ? _i < n : _i > n; i = last <= n ? ++_i : --_i) {
      if (__indexOf.call(prefix, i) < 0) {
        return true;
      }
    }
    return false;
  };

  nextAvailable = function(prefix, n) {
    var i, last, _i;
    last = _last(prefix);
    for (i = _i = last; last <= n ? _i < n : _i > n; i = last <= n ? ++_i : --_i) {
      if (__indexOf.call(prefix, i) < 0) {
        return i;
      }
    }
    return null;
  };

  next = function(tree, n) {
    var prefix;
    prefix = tree.data.slice(0);
    if (prefix.length < n) {
      prefix.push(firstNotIn(prefix, n));
      tree = new Tree(tree, _last(prefix), tree.depth + 1, '#F00', prefix);
      return tree;
    }
    while (!(available(prefix, n) || (tree == null))) {
      prefix.pop();
      tree.color = '#FFF';
      tree = tree.parent;
    }
    if (tree == null) {
      return null;
    }
    prefix[prefix.length - 1] = nextAvailable(prefix, n);
    tree.color = '#FFF';
    tree = new Tree(tree.parent, _last(prefix), tree.depth, '#F00', prefix);
    return tree;
  };

  window.dfsanim = dfsanim = function(ctx, n, tree) {
    if (tree == null) {
      tree = new Tree(null, '', 0, '#F00', []);
    }
    tree = next(tree, n);
    if (tree != null) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      tree.getRoot().draw(ctx);
      return setTimeout((function() {
        return dfsanim(ctx, n, tree);
      }), 500);
    }
  };

  window.binaryanim = binaryanim = function(ctx, n, tree) {
    if (tree == null) {
      tree = new Tree(null, '', 0, '#F00');
    }
    if (tree.value.length === n || tree.children.length === 2) {
      tree.color = '#FFF';
      tree = tree.parent;
    } else if (tree.children.length === 1) {
      tree = new Tree(tree, tree.value + '1', tree.depth + 1, '#F00');
    } else if (tree.children.length === 0) {
      tree = new Tree(tree, tree.value + '0', tree.depth + 1, '#F00');
    }
    if (tree != null) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      tree.getRoot().draw(ctx);
      return setTimeout((function() {
        return binaryanim(ctx, n, tree);
      }), 500);
    }
  };

}).call(this);
